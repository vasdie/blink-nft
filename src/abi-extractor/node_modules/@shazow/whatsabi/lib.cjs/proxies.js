"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.slotResolvers = exports.slots = exports.FixedProxyResolver = exports.SequenceWalletProxyResolver = exports.PROXIABLEProxyResolver = exports.ZeppelinOSProxyResolver = exports.DiamondProxyResolver = exports.EIP1967ProxyResolver = exports.LegacyUpgradeableProxyResolver = exports.GnosisSafeProxyResolver = exports.BaseProxyResolver = void 0;
const slots_js_1 = require("./slots.js");
const utils_js_1 = require("./utils.js");
const _zeroAddress = "0x0000000000000000000000000000000000000000";
function addressFromPadded(data) {
    return "0x" + data.slice(data.length - 40);
}
class BaseProxyResolver {
    name;
    constructor(name) {
        this.name = name || this.constructor.name;
    }
    toString() {
        return this.name;
    }
}
exports.BaseProxyResolver = BaseProxyResolver;
class GnosisSafeProxyResolver extends BaseProxyResolver {
    async resolve(provider, address) {
        const slotPosition = 0;
        return addressFromPadded(await provider.getStorageAt(address, slotPosition));
    }
}
exports.GnosisSafeProxyResolver = GnosisSafeProxyResolver;
class LegacyUpgradeableProxyResolver extends BaseProxyResolver {
    async resolve(provider, address) {
        const slotPosition = 1;
        return addressFromPadded(await provider.getStorageAt(address, slotPosition));
    }
}
exports.LegacyUpgradeableProxyResolver = LegacyUpgradeableProxyResolver;
const EIP1967FallbackSelectors = [
    "0x5c60da1b",
    "0xda525716",
    "0xa619486e",
    "0xbb82aa5e",
];
class EIP1967ProxyResolver extends BaseProxyResolver {
    name = "EIP1967Proxy";
    async resolve(provider, address) {
        const implAddr = addressFromPadded(await provider.getStorageAt(address, exports.slots.EIP1967_IMPL));
        if (implAddr !== _zeroAddress) {
            return implAddr;
        }
        const fallbackAddr = addressFromPadded(await provider.getStorageAt(address, exports.slots.EIP1967_BEACON));
        if (fallbackAddr === _zeroAddress) {
            return _zeroAddress;
        }
        for (const selector of EIP1967FallbackSelectors) {
            try {
                const addr = addressFromPadded(await provider.call({
                    to: fallbackAddr,
                    data: selector,
                }));
                if (addr !== _zeroAddress)
                    return addr;
            }
            catch (e) {
                if (e.toString().includes("revert"))
                    continue;
                throw e;
            }
        }
        return _zeroAddress;
    }
}
exports.EIP1967ProxyResolver = EIP1967ProxyResolver;
const diamondSelectors = [
    "0xcdffacc6",
    "0x0d741577",
];
class DiamondProxyResolver extends BaseProxyResolver {
    name = "DiamondProxy";
    storageSlot;
    constructor(name, overrideStorageSlot) {
        super(name);
        this.storageSlot = overrideStorageSlot ?? exports.slots.DIAMOND_STORAGE;
    }
    async resolve(provider, address, selector) {
        if (!selector) {
            throw "DiamondProxy requires a selector to resolve to a specific facet";
        }
        else if (selector.startsWith("0x")) {
            selector = selector.slice(2);
        }
        const facetMappingSlot = (0, slots_js_1.joinSlot)([selector.padEnd(64, "0"), this.storageSlot]);
        const facet = await provider.getStorageAt(address, facetMappingSlot);
        const storageAddr = "0x" + facet.slice(facet.length - 40);
        if (storageAddr !== _zeroAddress) {
            return storageAddr;
        }
        for (const facetSelector of diamondSelectors) {
            try {
                const addr = addressFromPadded(await provider.call({
                    to: address,
                    data: facetSelector + selector,
                }));
                if (addr !== _zeroAddress)
                    return addr;
            }
            catch (e) {
                if (e.toString().includes("revert"))
                    continue;
                throw e;
            }
        }
        return _zeroAddress;
    }
    async facets(provider, address, config) {
        let limit = config?.limit || 0;
        const storageStart = this.storageSlot;
        const facetsOffset = (0, slots_js_1.addSlotOffset)(storageStart, 2);
        const addressWidth = 20;
        const facets = await (0, slots_js_1.readArray)(provider, address, facetsOffset, addressWidth);
        const selectorWidth = 4;
        const facetSelectors = {};
        const slot = (0, slots_js_1.addSlotOffset)(storageStart, 1);
        for (const f of facets) {
            const facet = addressFromPadded(f);
            const facetSelectorsSlot = (0, slots_js_1.joinSlot)([facet, slot]);
            const selectors = await (0, slots_js_1.readArray)(provider, address, facetSelectorsSlot, selectorWidth);
            facetSelectors[(0, utils_js_1.addressWithChecksum)(facet)] = selectors.map(s => "0x" + s);
            if (--limit === 0)
                break;
        }
        return facetSelectors;
    }
    async selectors(provider, address) {
        const f = await this.facets(provider, address);
        return Object.values(f).flat();
    }
}
exports.DiamondProxyResolver = DiamondProxyResolver;
class ZeppelinOSProxyResolver extends BaseProxyResolver {
    name = "ZeppelinOSProxy";
    async resolve(provider, address) {
        return addressFromPadded(await provider.getStorageAt(address, exports.slots.ZEPPELINOS_IMPL));
    }
}
exports.ZeppelinOSProxyResolver = ZeppelinOSProxyResolver;
class PROXIABLEProxyResolver extends BaseProxyResolver {
    name = "PROXIABLEProxy";
    async resolve(provider, address) {
        return addressFromPadded(await provider.getStorageAt(address, exports.slots.PROXIABLE));
    }
}
exports.PROXIABLEProxyResolver = PROXIABLEProxyResolver;
class SequenceWalletProxyResolver extends BaseProxyResolver {
    name = "SequenceWalletProxy";
    async resolve(provider, address) {
        return addressFromPadded(await provider.getStorageAt(address, address.toLowerCase().slice(2)));
    }
}
exports.SequenceWalletProxyResolver = SequenceWalletProxyResolver;
class FixedProxyResolver extends BaseProxyResolver {
    name = "FixedProxy";
    resolvedAddress;
    constructor(name, resolvedAddress) {
        super(name);
        this.resolvedAddress = resolvedAddress;
    }
    async resolve(provider, address) {
        return this.resolvedAddress;
    }
}
exports.FixedProxyResolver = FixedProxyResolver;
;
exports.slots = {
    EIP1967_IMPL: "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc",
    EIP1967_BEACON: "0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50",
    ZEPPELINOS_IMPL: "0x7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c036e5a723fd8ee048ed3f8c3",
    PROXIABLE: "0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7",
    GNOSIS_SAFE_SELECTOR: "0xa619486e00000000000000000000000000000000000000000000000000000000",
    DIAMOND_STORAGE: "0xc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131b",
    DIAMOND_STORAGE_1: "0xc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131c",
};
exports.slotResolvers = {
    [exports.slots.EIP1967_IMPL]: new EIP1967ProxyResolver("EIP1967Proxy"),
    [exports.slots.EIP1967_BEACON]: new EIP1967ProxyResolver("EIP1967Proxy"),
    [exports.slots.ZEPPELINOS_IMPL]: new ZeppelinOSProxyResolver("ZeppelinOSProxy"),
    [exports.slots.PROXIABLE]: new PROXIABLEProxyResolver("PROXIABLE"),
    [exports.slots.GNOSIS_SAFE_SELECTOR]: new GnosisSafeProxyResolver("GnosisSafeProxy"),
    [exports.slots.DIAMOND_STORAGE]: new DiamondProxyResolver("DiamondProxy"),
    [exports.slots.DIAMOND_STORAGE_1]: new DiamondProxyResolver("DiamondProxy", exports.slots.DIAMOND_STORAGE_1),
    "0xc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131d": new DiamondProxyResolver("DiamondProxy"),
    "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbd": new EIP1967ProxyResolver("EIP1967Proxy"),
};
//# sourceMappingURL=proxies.js.map